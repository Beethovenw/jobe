<?php defined('BASEPATH') OR exit('No direct script access allowed');

/* ==============================================================
 *
 * This file defines the abstract Task class, a subclass of which
 * must be defined for each implemented language.
 *
 * ==============================================================
 *
 * @copyright  2014 Richard Lobb, University of Canterbury
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

require_once('application/libraries/resultobject.php');

define('ACTIVE_USERS', 1);  // The key for the shared memory active users array
define('MAX_RETRIES', 5);   // Maximum retries (1 secs per retry), waiting for free user account

class OverloadException extends Exception {
}


abstract class Task {

    // Symbolic constants as per ideone API

    const RESULT_COMPILATION_ERROR = 11;
    const RESULT_RUNTIME_ERROR = 12;
    const RESULT_TIME_LIMIT   = 13;
    const RESULT_SUCCESS      = 15;
    const RESULT_MEMORY_LIMIT    = 17;
    const RESULT_ILLEGAL_SYSCALL = 19;
    const RESULT_INTERNAL_ERR = 20;
    const RESULT_SERVER_OVERLOAD = 21;

    // Global default parameter values. Can be overridden by subclasses,
    // and then further overridden by the individual run requests.
    public $default_params = array(
        'disklimit'     => 20,      // MB (for normal files)
        'streamsize'    => 2,       // MB (for stdout/stderr)
        'cputime'       => 5,       // secs
        'memorylimit'   => 200,     // MB
        'numprocs'      => 20,
        'compileargs'   => array(),
        'interpreterargs' => array(),
        'runargs'       => array()
    );

    public $id;             // The task id - use the workdir basename
    public $input;          // Stdin for this task
    public $sourceFileName; // The name to give the source file
    public $params;         // Request parameters
    
    public $cmpinfo = '';   // Output from compilation
    public $time = 0;       // Execution time (secs)
    public $memory = 0;     // Memory used (MB)
    public $signal = 0;
    public $stdout = '';    // Output from execution
    public $stderr = '';
    public $result = Task::RESULT_INTERNAL_ERR;  // Should get overwritten
    public $workdir = '';   // The temporary working directory created in constructor


    // For all languages it is necessary to store the source code in a
    // temporary file when constructing the task. A temporary directory
    // is made to hold the source code. The standard input ($input) and
    // the run parameters ($params) are saved for use at runtime.
    // WARNING: the /home/jobe/runs directory (below) is generated by the installer. 
    // If you change that directory for some reason, make sure the directory
    // exists, is owned by jobe, with group www-data (or whatever your web
    // server user is) and has access rights of 771. If it's readable by
    // the webserver or any of the jobe<n> users, running programs will be able
    // to hoover up other students' submissions.
    public function __construct($sourceCode, $filename, $input, $params) {
        $this->workdir = tempnam("/tmp", "jobe_");
        if (!unlink($this->workdir) || !mkdir($this->workdir)) {
            log_message('error', 'LanguageTask constructor: error making temp directory');
            throw new Exception("Task: error making temp directory (race error?)");
        }
        $this->id = basename($this->workdir);
        $this->input = $input;
        if (empty($filename)) {
            $filename = $this->defaultFileName($sourceCode);
        }
        $this->sourceFileName = $filename;
        $this->params = $params;
        $this->cmpinfo = '';  // Optimism (always look on the bright side of life_
        chdir($this->workdir);
        $handle = fopen($this->sourceFileName, "w");
        fwrite($handle, $sourceCode);
        fclose($handle);
    }


    protected function getParam($key) {
        if (isset($this->params) && array_key_exists($key, $this->params)) {
            return $this->params[$key];
        } else {
            return $this->default_params[$key];
        }
    }
    

    // Return the JobeAPI result object to describe the state of this task
    public function resultObject() {
        if ($this->cmpinfo) {
            $this->result = Task::RESULT_COMPILATION_ERROR;
        }
        return new ResultObject(
            $this->workdir,
            $this->result,
            $this->cmpinfo,
            $this->filteredStdout(),
            $this->filteredStderr()
        );
    }

    
    // Load the specified files into the working directory.
    // The file list is an array of (fileId, filename) pairs.
    // Return False if any are not present.
    public function load_files($fileList, $filecachedir) {
        foreach ($fileList as $file) {
            $fileId = $file[0];
            $filename = $file[1];
            $path = $filecachedir . $fileId;
            $destPath = $this->workdir . '/' . $filename;
            if (!file_exists($path) || 
               ($contents = file_get_contents($path)) === FALSE ||
               (file_put_contents($destPath, $contents)) === FALSE) {
                return FALSE;
            }
        }
        return TRUE;
    }

    // Compile the current source file in the current directory, saving
    // the compiled output in a file $this->executableFileName.
    // Sets $this->cmpinfo accordingly.
    public abstract function compile();

       
    // Execute this task, which must already have been compiled if necessary
    // This version has no resource controls (which is why this is the
    // 'unsafe' branch)!
    public function execute() {

        try {
            // Establish all the parameters for the job run
            
            // Can't do anything with all the following in this unprotected
            // version but leave the code there for future use
            $filesize = 1000 * $this->getParam('disklimit'); // MB -> kB
            $streamsize = 1000 * $this->getParam('streamsize'); // MB -> kB
            $memsize = 1000 * $this->getParam('memorylimit');
            $cputime = $this->getParam('cputime');
            $numProcs = $this->getParam('numprocs');

            $cmd = implode(' ', $this->getRunCommand());
            $cmd .= " >prog.out 2>prog.err";

            // Set up the work directory and run the job
            $workdir = $this->workdir;
            chdir($workdir);
            file_put_contents('prog.cmd', $cmd);

            if ($this->input != '') {
                $f = fopen('prog.in', 'w');
                fwrite($f, $this->input);
                fclose($f);
                $cmd .= " <prog.in";
            }
            else {
                $cmd .= " </dev/null";
            }

            $handle = popen($cmd, 'r');
            $result = fread($handle, MAX_READ);
            pclose($handle);
            
            // Copy results back out into this object
            
            $this->stdout = file_get_contents("$workdir/prog.out");
            
            if (file_exists("$workdir/prog.err")) {
                $this->stderr = file_get_contents("$workdir/prog.err");
            }
            
            $this->stderr = $this->filteredStderr();
            $this->diagnose_result();  // Analyse output and set result
        }
        catch (OverloadException $e) {
            $this->result = Task::RESULT_SERVER_OVERLOAD;
            $this->stderr = $e->getMessage();
        }
        catch (Exception $e) {
            $this->result = Task::RESULT_INTERNAL_ERR;
            $this->stderr = $e->getMessage();
        }

    }

    // Return the Linux command to use to run the current job with the given
    // standard input. It's an array of strings, which when joined with a
    // a space character makes a bash command. The default is to use the
    // name of the executable from getExecutablePath() followed by the strings
    // in the 'interpreterargs' parameter followed by the name of the target file
    // as returned by getTargetFile() followed by the strings in the
    // 'runargs' parameter. For compiled languages, getExecutablePath
    // should generally return the path to the compiled object file and
    // getTargetFile() should return the empty string. The interpreterargs
    // and runargs parameters are then just added (in that order) to the
    // run command. For interpreted languages getExecutablePath should return
    // the path to the interpreter and getTargetFile() should return the
    // name of the file to be interpreted (in the current directory).
    // This design allows for commands like java -Xss256k thing -blah.
    
    public function getRunCommand() {
        $cmd = array($this->getExecutablePath());
        $cmd = array_merge($cmd, $this->getParam('interpreterargs'));
        if ($this->getTargetFile()) {
            $cmd[] = $this->getTargetFile();
        }
        $cmd = array_merge($cmd, $this->getParam('runargs')); 
        return $cmd;
    }
    
    
    // Return a suitable default filename for the given sourcecode.
    // Usually of form prog.py, prog.cpp etc but Java is a special case.
    public abstract function defaultFileName($sourcecode);
    

    // Return the path to the executable that runs this job. For compiled
    // languages this will be the output from the compilation. For interpreted
    // languages it will be the path to the interpreter or JVM etc.
    public abstract function getExecutablePath(); 
    
    
    // Return the name of the so called "target file", which will typically be empty
    // for compiled languages and will be the name of the file to be interpreted
    // (usually just $this->executableFileName) for interpreted languages.
    public abstract function getTargetFile();
    
    
    // Return the version of language supported by this particular Language/Task
    public static function getVersion() {
        return '';  // To be overridden by subclass
    }

    
    // Called after each run to set the task result value. Default is to
    // set the result to SUCCESS if there's no stderr output or to timelimit
    // exceeded if the appropriate warning message is found in stdout or
    // to runtime error otherwise.
    // Note that Runguard does not identify memorylimit exceeded as a special
    // type of runtime error so that value is not returned by default.
    
    // Subclasses may wish to add further postprocessing, e.g. for memory
    // limit exceeded if the language identifies this specifically.
    public function diagnose_result() {
        if (strlen($this->filteredStderr())) {
            $this->result = TASK::RESULT_RUNTIME_ERROR;
        } else {
            $this->result = TASK::RESULT_SUCCESS;
        } 
        
        // Refine RuntimeError if possible

        if (strpos($this->stderr, "warning: timelimit exceeded")) {
            $this->result = Task::RESULT_TIME_LIMIT;
            $this->signal = 9;
            $this->stderr = '';
        } else if(strpos($this->stderr, "warning: command terminated with signal 11")) {
            $this->signal = 11;
            $this->stderr = '';
        }
    }

    
    // Override the following function if the output from executing a program
    // in this language needs post-filtering to remove stuff like
    // header output.
    public function filteredStdout() {
        return $this->stdout;
    }


    // Override the following function if the stderr from executing a program
    // in this language needs post-filtering to remove stuff like
    // backspaces and bells.
    public function filteredStderr() {
        return $this->stderr;
    }


    // Called to clean up task when done
    public function close($deleteFiles=TRUE) {
        if ($deleteFiles) {
            $dir = $this->workdir;
            exec("sudo rm -R $dir");
        }
    }

    // Check if PHP exec environment includes a PATH. If not, set up a
    // default, or gcc misbehaves. [Thanks to Binoj D for this bug fix,
    // needed on his CentOS system.]
    protected function setPath() {
        $envVars = array();
        exec('printenv', $envVars);
        $hasPath = FALSE;
        foreach ($envVars as $var) {
            if (strpos($var, 'PATH=') === 0) {
                $hasPath = TRUE;
                break;
            }
        }
        if (!$hasPath) {
            putenv("PATH=/sbin:/bin:/usr/sbin:/usr/bin");
        }
    }

}


?>
